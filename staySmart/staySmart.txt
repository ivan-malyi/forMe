Логический анализатор 

	Представьте, что вы хотите создать умный дом, в котором свет включается с помощью контроллера и датчика движения.

	Вы написали программу, и подключили к контроллеру датчик, но тут замечаете, что схема работает не правильно: свет не включается.

	Чтобы точно понять, в чем ошибка - в программе или же датчике движения, вы подключаете логический анализатор к двум выходам : 
	
	1. Из датчика движения, чтобы считывать его состояние в нужный момент
	2. К выводу микроконтроллера, через который происходит управление светом, например, через реле, чтобы считывать его состояние в нужный момент 
	

	Таким образом : 
	* Если сигнал от датчика приходит правильно, но микроконтроллер на него не реагирует, значит, проблема в программе.
	* Если сигнал от датчика не поступает, значит, проблема в самом датчике или его подключении.


	Подключение цифрового анализатора к компьютеру: 
	Анализатор мы подсоединяем через USB к компьютеру и через специальную отлаживающую программу (среду разработки), которую часто предлагает именно сама компания-
	производитель, затем анализируем полученный результат.


	Мы в этой программе, настраиваем каналы, которые хотим слушать и выбираем интерфейс, через который мы работаем (SPI, UART, I2C...)









PLL(Phase-Locked Loop) — Фазовая автоподстройка частоты

	**Основные задачи PLL:**

	1. Генерация тактового сигнала:
		* Используется в микроконтроллерах для повышения тактовой частоты внутреннего ядра.
		* Например, если внешний кварц (осциллятор) имеет частоту 8 МГц, с помощью PLL можно увеличить частоту до 72 МГц для работы ядра.

	2. Синхронизация частот:
		* Для обеспечения стабильности тактовых сигналов в устройствах, таких как процессоры, модули связи (Wi-Fi, Bluetooth), радиопередатчики.

	3.Множитель частоты:
		* PLL может увеличивать частоту осциллятора для достижения высоких частот, необходимых для работы современных цифровых устройств.





RIC(Reset and Initialization Circuit) — Схема сброса и инициализации


	** Основные задачи RIC: **
	

	1.Обеспечение стабильного запуска устройства:
		* Когда микроконтроллер включается, RIC держит его в состоянии сброса до стабилизации напряжения питания (VDD).

	2.Мониторинг напряжения питания:
		* Если напряжение питания падает ниже допустимого уровня, RIC инициирует сброс устройства, чтобы избежать некорректной работы.

	3.Инициализация периферии:
		* RIC может автоматически запускать периферийные устройства и модули после сброса.




	*** Пример работы RIC: **


	* При подаче питания микроконтроллер STM32 остаётся в состоянии сброса, пока напряжение питания не достигнет стабильного уровня (определяется функцией Power-On Reset, 	POR).

	* После этого RIC запускает внутренние осцилляторы, настраивает PLL и разрешает выполнение пользовательского кода.










HAL и LL библеотеки
	**Простое описание**
		Представьте, что вы хотите пиццу. У вас есть два варианта выбора: 
		1. Позвонить на горячую линию пиццерии и дать короткие указания (адрес доставки, какую пиццу хотите...).
		2. Приготовить пиццу самостоятельно, применив больше усилий, но лучше разобравшись в деле.
		
	В первом случае все сделают за вас, от вас только нужны определенные указания. 
	Во втором случае все прийдется сделать самостоятельно и уткнуться в работу с деталями.


	** Как это связано с микроконтроллерами? ** 
		HAL (Аппаратный уровень абстракции):
			Это высокоуровневая библиотека, которая упрощает работу с микроконтроллером.
			Она предоставляет функции, которые делают всё "автоматически". Вы просто говорите, что вам нужно, а детали уже скрыты.
			Пример: вы хотите включить светодиод. В HAL это выглядит так:

				"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);"

			Здесь:
				Вы указываете, что нужно включить пин (GPIO_PIN_5) на порте (GPIOA).
				HAL автоматически разберётся, как это сделать.
	
	

		LL (Низкоуровневый уровень):
			Это библиотека для работы на более "глубоком" уровне.
			Вы должны вручную настроить все параметры. Это сложнее, но даёт больше контроля.
			Пример: включение того же светодиода с использованием LL:

				"LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_5);"

			Здесь:
				Вы явно задаёте команду включения для конкретного пина.
				Возможно, вам нужно было заранее настроить порт вручную.







STM32 Cube IDE


	STM32CubeIDE — это интегрированная среда разработки (IDE) для работы с микроконтроллерами серии STM32 от STMicroelectronics. Она создана для упрощения разработки и 	отладки приложений, работающих на этих микроконтроллерах.


	**Преимущества STM32CubeIDE **
	Представьте, что вы хотите написать проект на базе STM32 и вам нужна среда разработки, для того чтобы:
	
	* Писать в ней код на С/С++
	* Отлаживать этот код
	* Настраивать пины и их функции (SPI, UART, I2C, GPIO...)
	* Включать/выключать переферийные устройства, 
	* Задавать тактовую частоту, использовать PLL, настроить RTC и таймеры. 



	** Генерация тестового кода, по заданным настройкам **
	На основе настроек, которые мы перечислили сверху, STM32CubeIDE генерирует стартовый код, который мы можем подредактировать и дописать, как нам угодно.


	** Отладка **
	* Позволяет отлаживать код в реальном времени через интерфейсы SWD или JTAG.
	* Встроенный отладчик помогает просматривать значения переменных, устанавливать точки останова, отслеживать выполнение программы.



	** Загрузка прошивки напрямую **
	Прошивка на микроконтроллер загружается напрямую через STM32CubeIDE (с помощью программаторов, таких как ST-LINK)


	** Интеграция с дополнительными библиотеками и RTOS: **

	* Поддерживает работу с FreeRTOS и другими операционными системами реального времени.
	* Поддержка HAL (Hardware Abstraction Layer) и LL (Low Layer) библиотек.



	** Поддержка всего семейства STM32: **

	* Подходит для всех микроконтроллеров STM32 (F0, F1, F2, F3, F4, F7, G0, H7, L0, L4, WB и т.д.).








TrueSTUDIO 

	TrueSTUDIO  или в простонародии «Толик» - среда разработки для микроконтроллеров, ранее созданная компанией Atollic, ориентированная на работу с микроконтроллерами 	ARM, в том числе STM32 от STMicroelectronics.
	После приобретения Atollic компанией STMicroelectronics TrueSTUDIO стало бесплатным и интегрированным в экосистему STM32.

	** Преимущества STM32 Cube IDE над TrueSTUDIO **

	Сейчас в основном используется, людьми, которые уже привыкли и не хотят слазить с старой версии IDE. Для людей, готовыми знакомится с чем-то новым, сейчас 	рекомендуется "STM32 Cube IDE" из-за ряда преимуществ: 
	1. Постоянно обновляется, в отличие от TrueSTUDIO, который постепенно устаревает.
	2. Более современный и удобный интерфейс 
	3. Интеграция и целенаправленная работа с STM32, в отличие от TrueSTUDIO, который разрабатывался, как независимый продукт.


	К сожалению, если мы не захотим прописывать что то в файла, подтягивая библиотеки и прописывая пути, а хотим получить некий преднастроенный файл, в котором можно без 	лишних заморочек писать код - нам придется, так или иначе использовать алгоритмы Cube MX или в простонародии «Калокуб» , чтобы использовать генератор программного 	кода.




Bootloader на Arduino и STM32

	Когда работаешь с Arduino, даже не замечаешь его удобства в использовании. Как только вы переходите на более коммерческие и требующие аппаратной мощности продукт, вы 	начинаете замечать, кое-какие, возможно, неудобства, по началу. 

	Например, при работе с STM32 вы узнаете, что стандартный используемый способ прошивки - через программатор ST-Link. Но это ни в коем случае не ограничение STM32, ведь 	он поддерживает два метода загрузки прошивки в flash-память - через программатор и через bootloader, а его особенность и гибкость. STM32 поддерживает прошивку через 	все основные интерфейси передачи данных (SPI, UART, I2C) так же bootloader через USB шину.






GPIO interface 


	GPIO интерфейс, это один из ключевых интерфейсов на микроконтроллерах, в виду малого места и требующего большого функционала ? 

	Сейчас уже почти все "цифровые" пины работают по протоколу GPIO , которые обязует их придерживаться определенного регламента - "Контакты GPIO могут выступать как в 	роли входа, так и в роли выхода — это, как правило, конфигурируется".

	Так же GPIO порты(пины) можно призначить, для обработки информации с различных низкоуровневых протоколов передачи данных, таких, как : (SPI, UART, I2C и прочие).

	Следует понимать, что этот интерфейс является универсальным, и не считая низкоуровневых протоколов передачи данных, является почти что единственным, за счет своей 	универсальности и гибкости.






IoT 
	Интернет вещей (Internet of Things, IoT) — это множество физических объектов, подключенных к интернету и обменивающихся данными.
	Концепция IoT может существенно улучшить многие сферы нашей жизни и помочь нам в создании более удобного, умного и безопасного мира.




GET/POST запросы - HTTP-протокол

	GET-запросы предназначены для получения данных от сервера. Когда мы вводим какие то данные в поисковик и нажиамем "Enter" - именно в этот момент
	сервер шлет нам поток GET-запросов, которые наш поисковик (Google, Firefox..) обрабатывает и отображает нам.

	POST-запросы нужны нам для того чтобы отпарвлять серверу какую-нибудь информацию, например когда мы переходим на сайт и он нам предлагает аиутентификацию (ввести имя и пароль)
	тогда мы вводим и нажимаем кнопку "Ввойти", после чего мы отпарвляем серверу эти данные в post-запросе и зачастую сервер отправляет нам данные в ответ в виде GET-запроса (не 
	POST-запроса, поскольку к серверу применима та же логика отпарвки, что для клиента: что дял клиента get-запрос, то и для сервера get-запрос, что дял клиента post-запрос, то и 
	для сервера post-запрос)



	Что стоит понимать о HTTP-протоколе и GET/POST запросов: 

	1.HTTP — это протокол, который описывает, как клиент и сервер общаются друг с другом.
		Сервер всегда отвечает HTTP-ответом (например, код состояния, заголовки и данные).

	2.GET и POST — это методы HTTP-запросов, которые используются клиентом для взаимодействия с сервером.
		GET: Клиент запрашивает данные (например, веб-страницу или файл).
		POST: Клиент отправляет данные на сервер (например, форму или JSON).

	3.Связь:
		Клиент отправляет запрос (например, GET или POST) по протоколу HTTP.
		Сервер обрабатывает запрос и возвращает HTTP-ответ (независимо от типа запроса).

	Пример:
		GET-запрос: Клиент хочет получить страницу -> Сервер отвечает HTML-кодом.
		POST-запрос: Клиент отправляет данные -> Сервер подтверждает или возвращает результат.